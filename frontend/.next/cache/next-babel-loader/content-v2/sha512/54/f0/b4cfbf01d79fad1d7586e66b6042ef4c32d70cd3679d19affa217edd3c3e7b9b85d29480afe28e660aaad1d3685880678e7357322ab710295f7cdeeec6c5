{"ast":null,"code":"import React from \"react\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/** @jsx jsx */\nimport { useState, useEffect, useContext, useRef } from \"react\";\nimport { jsx, Box, Flex, Container, Heading, Text, Input, Button, Image } from \"theme-ui\";\nimport { rgba } from \"polished\";\nimport { ethers } from \"ethers\";\nimport Loader from \"react-loader-spinner\";\nimport CanvasText from \"components/canvasText/CanvasText\";\nimport CanvasSignature from \"components/canvasText/canvasSignature\";\nimport Modal from \"components/modal/\";\nimport ConfettiComponent from \"components/confetti/\";\nimport RadioSelect from \"components/radio\";\nimport { getContract } from \"utils/getContact\";\nimport { exportSignatureAsSVG, exportSignatureAsPNGFile, convertToBuffer, addDataToIPFS, retrieveDataFromIPFS, createNFTMeta, IPFS_RETRIEVE_URL } from \"utils/signature\";\nimport { Web3CreateContext } from \"contexts/web3-context\";\nimport { defaultProvider } from \"utils/web3connect\";\nimport { TRANSACTION_LINK, OPENSEA_LINK, OPENSEA_COLLECTION_LINK } from \"utils/constants\";\nimport { calculateSignatureSizePrice } from \"utils/getSignatureSizePrice\";\nimport paypal from \"assets/images/paypal.png\";\nimport google from \"assets/images/google.png\";\nimport dropbox from \"assets/images/dropbox.png\";\nexport const txnStatusType = {\n  CONFIRMED: \"CONFIRMED\",\n  PENDING: \"PENDING\",\n  REVERTED: \"REVERTED\"\n}; // if true then use canvas to create singature else create and use SVG as an NFT\n\nconst enableCanvasSignature = true;\n\nconst HomePage = () => {\n  const {\n    state\n  } = useContext(Web3CreateContext);\n  const {\n    address,\n    web3Provider\n  } = state;\n  const textCanvasRef = useRef();\n  const handwrittenCanvasRef = useRef();\n  const {\n    0: signature,\n    1: setSignature\n  } = useState(\"\");\n  const {\n    0: randomName,\n    1: setRandomName\n  } = useState(\"\");\n  const {\n    0: xPricePerUnit,\n    1: setXPricePerUnit\n  } = useState(2);\n  const {\n    0: pricePerUnit,\n    1: setPricePerUnit\n  } = useState(0.5);\n  const {\n    0: customSignatureUnits,\n    1: setCustomSignatureUnits\n  } = useState([8, 16, 24]);\n  const {\n    0: isEligibleToMint,\n    1: setIsEligibleToMint\n  } = useState(false);\n  const {\n    0: showConfetti,\n    1: setShowConfetti\n  } = useState(false);\n  const {\n    0: isEligibleToDiscount,\n    1: setIsEligibleToDiscount\n  } = useState(false);\n  const {\n    0: existingSignature,\n    1: setExistingSignature\n  } = useState();\n  const {\n    0: isLoading,\n    1: setIsLoading\n  } = useState(false);\n  const {\n    0: totalPrice,\n    1: setTotalPrice\n  } = useState(0);\n  const {\n    0: toggleHandSignature,\n    1: setToggleHandSignature\n  } = useState(false);\n  const {\n    0: txn,\n    1: setTxn\n  } = useState();\n  const {\n    0: openModal,\n    1: setOpenModal\n  } = useState(false);\n  const {\n    0: errorMessage,\n    1: setErrorMessage\n  } = useState(\"\");\n\n  const getSignature = async () => {\n    let signatureNFT;\n\n    if (toggleHandSignature) {\n      // HandwrittenSignature\n      const base64EncodedImage = getHandwrittenCanvasSignature();\n      signatureNFT = await exportSignatureAsPNGFile(base64EncodedImage);\n    } else if (enableCanvasSignature) {\n      // Export text signature from canvas as png\n      const base64EncodedImage = getTextCanvasSignature();\n      signatureNFT = await exportSignatureAsPNGFile(base64EncodedImage);\n    } else {\n      // Export text signature as SVG\n      const signatureSVG = exportSignatureAsSVG(signature);\n      signatureNFT = await convertToBuffer(signatureSVG);\n    }\n\n    return signatureNFT;\n  };\n\n  const onClaimNFT = async e => {\n    e.preventDefault();\n\n    if (!signature) {\n      setErrorMessage(\"Please either draw or type a signature before claiming the NFT\");\n      return;\n    }\n\n    if (!web3Provider) {\n      setErrorMessage(\"Please connect your wallet first before claiming the NFT\");\n      return;\n    }\n\n    if (signature || web3Provider) {\n      setErrorMessage(\"\");\n    }\n\n    const signatureNFT = await getSignature();\n    if (!signatureNFT) return; // Add signature to IPFS\n\n    const imghash = await addDataToIPFS(signatureNFT, true); // // Create NFT metadata and add it to IPFS\n\n    const nftMetadata = createNFTMeta(imghash, signature);\n    const ipfsNFTMetadata = await addDataToIPFS(nftMetadata);\n    const signer = web3Provider.getSigner();\n    const contract = getContract(signer);\n    const mintValue = ethers.utils.parseEther(totalPrice);\n    const nftTxn = await contract.mintSignature(signature.length, signature, `ipfs://${ipfsNFTMetadata}`, {\n      value: mintValue,\n      gasLimit: 6000000\n    });\n    setTxn({\n      mintedOn: new Date().toDateString(),\n      txnStatus: txnStatusType.PENDING,\n      txnValue: mintValue,\n      txnHash: nftTxn.hash,\n      txnLink: TRANSACTION_LINK + nftTxn.hash\n    });\n    setOpenModal(true);\n\n    try {\n      await nftTxn.wait();\n    } catch (error) {\n      console.log(error);\n    }\n\n    await getTransactionReceipt(nftTxn.hash);\n  };\n\n  const getTransactionReceipt = async txnHash => {\n    const txReceipt = await web3Provider.getTransactionReceipt(txnHash); // The status of a transaction is 1 is successful or 0 if it was reverted.\n    // The block hash of the block that this transaction was included in.\n\n    if (txReceipt && txReceipt.blockNumber && txReceipt.status) {\n      setTxn(prevTxn => _objectSpread(_objectSpread({}, prevTxn), {}, {\n        txnStatus: txnStatusType.CONFIRMED,\n        gasUsed: txReceipt.gasUsed.toString() //The amount of gas actually used by this transaction.\n\n      }));\n      return;\n    }\n\n    setTxn(prevTxn => _objectSpread(_objectSpread({}, prevTxn), {}, {\n      txnStatus: txnStatusType.REVERTED,\n      gasUsed: txReceipt.gasUsed.toString()\n    }));\n  };\n\n  const testModal = async () => {\n    const txnHash = \"0x6c8ee629793671f46cab0d5571560e3f2716b6ab520fbc7994c9da3c446d9f15\";\n    setTxn({\n      mintedOn: new Date().toDateString(),\n      txnStatus: txnStatus.PENDING,\n      txnValue: 1000,\n      txnHash: txnHash,\n      txnLink: TRANSACTION_LINK + txnHash\n    });\n    setOpenModal(true);\n    let timer = setTimeout(async () => {\n      await getTransactionReceipt(txnHash);\n    }, 5000); // clearTimeout(timer);\n  }; // Create a function to get random english names using API call\n\n\n  const getRandomName = async () => {\n    const response = await fetch(\"https://randomuser.me/api/?nat=us&results=1\");\n    const data = await response.json();\n    setRandomName(data.results[0].name.first + \" \" + data.results[0].name.last);\n  };\n\n  const getdefaultValuesFromContract = async () => {\n    const contract = getContract(defaultProvider);\n    let xPricePerUnit = await contract.xPricePerUnit();\n    let pricePerUnit = await contract.pricePerUnit();\n    let customSignatureUnits = await contract.getCustomSignatureUnits();\n    xPricePerUnit = ethers.utils.formatEther(xPricePerUnit).toString();\n    pricePerUnit = ethers.utils.formatEther(pricePerUnit).toString();\n    xPricePerUnit = parseFloat(xPricePerUnit);\n    pricePerUnit = parseFloat(pricePerUnit);\n    setXPricePerUnit(xPricePerUnit);\n    setPricePerUnit(pricePerUnit);\n    setCustomSignatureUnits(customSignatureUnits);\n  };\n\n  const getUserExistingMintedSignature = async itemId => {\n    if (!address) return;\n    const contract = getContract(defaultProvider);\n    const existingSignature = await contract.getSignature(address);\n    let ipfsHash = existingSignature[1];\n    ipfsHash = ipfsHash.replace(\"ipfs://\", \"\");\n    const meta = await retrieveDataFromIPFS(ipfsHash);\n\n    const currentSignature = _objectSpread(_objectSpread({}, meta.data), {}, {\n      ipfs_url: meta.data.web3Storage,\n      mintedOn: new Date(meta.data.attributes[1].value),\n      openseaNFT: `${OPENSEA_LINK}/${itemId - 1}`\n    });\n\n    setExistingSignature(currentSignature);\n    setIsLoading(false);\n    setShowConfetti(true);\n    setIsEligibleToMint(false);\n  };\n\n  const getUserInformation = async () => {\n    setIsLoading(true);\n    const contract = getContract(defaultProvider);\n    const isEligibleToDiscount = await contract.checkElegibleMember(address);\n    const isEligibleToMint = await contract.addressToSignature(address);\n\n    if (isEligibleToMint.toString() === \"0\") {\n      setIsEligibleToMint(true);\n      setExistingSignature(null);\n      setIsLoading(false);\n    } else {\n      // User has already minted the token\n      await getUserExistingMintedSignature(isEligibleToMint);\n    }\n\n    setIsEligibleToDiscount(isEligibleToDiscount);\n  };\n\n  const renderTextSignature = () => {\n    if (enableCanvasSignature) {\n      return jsx(CanvasText, {\n        changeText: signature || randomName,\n        ref: textCanvasRef\n      });\n    }\n\n    return jsx(\"h1\", {\n      sx: styles.signatureText\n    }, signature || randomName);\n  };\n\n  const renderCanvasInput = () => toggleHandSignature ? jsx(CanvasSignature, {\n    ref: handwrittenCanvasRef\n  }) : renderTextSignature();\n\n  const renderInput = () => !existingSignature ? jsx(React.Fragment, null, jsx(Input, {\n    type: \"text\",\n    placeholder: \"Enter Your Signature\",\n    value: signature || \"\",\n    onChange: onChangeTextSignature\n  }), jsx(Button, {\n    onClick: onClaimNFT\n  }, \"Claim NFT\")) : jsx(Text, {\n    as: \"h3\"\n  }, \"Our minions report that you have succesfully minted your signature NFT\", existingSignature && \" on \" + existingSignature.mintedOn.toDateString() + \" at \" + existingSignature.mintedOn.toLocaleTimeString());\n\n  const renderButton = () => {\n    if (existingSignature) {\n      return jsx(React.Fragment, null, jsx(\"a\", {\n        href: existingSignature.openseaNFT,\n        target: \"_blank\"\n      }, jsx(Button, {\n        variant: \"secondary\"\n      }, \"Check you signature NFT at Opensea\")), jsx(\"a\", {\n        href: OPENSEA_COLLECTION_LINK,\n        target: \"_blank\"\n      }, jsx(Button, null, \"Check Collection at Opensea\")));\n    }\n\n    return jsx(React.Fragment, null, jsx(Button, {\n      onClick: () => setToggleHandSignature(prevState => !prevState),\n      variant: \"secondary\"\n    }, toggleHandSignature ? \"Type your signature \" : \"Create your own custom handwritten signature\"), jsx(Button, {\n      onClick: clearSignature\n    }, \"Clear\"));\n  };\n\n  const getTextCanvasSignature = () => {\n    if (!textCanvasRef.current) return;\n    const textCanvasSignature = textCanvasRef.current.toDataURL(\"image/png\");\n    return textCanvasSignature;\n  };\n\n  const getHandwrittenCanvasSignature = () => {\n    if (!handwrittenCanvasRef.current) return;\n    const handSignature = handwrittenCanvasRef.current.toDataURL(\"image/png\");\n    return handSignature;\n  };\n\n  const clearSignature = () => {\n    if (toggleHandSignature) {\n      if (!handwrittenCanvasRef.current) return;\n      handwrittenCanvasRef.current.clear();\n      return;\n    }\n\n    setSignature(\" \");\n  };\n\n  const onCloseModal = async () => {\n    setOpenModal(prevState => !prevState);\n\n    if (txn && txn.txnStatus && txn.txnStatus === txnStatusType.CONFIRMED) {\n      setIsLoading(true);\n      await getUserInformation();\n      setShowConfetti(true);\n    }\n  };\n\n  const calaculateTextSingaturePriceValue = currentSignature => {\n    let price;\n\n    if (isEligibleToDiscount) {\n      price = currentSignature.length * pricePerUnit;\n    } else {\n      price = currentSignature.length * xPricePerUnit;\n    }\n\n    setSignature(currentSignature);\n    setTotalPrice(price.toFixed(3));\n  };\n\n  const onChangeTextSignature = event => {\n    const signature = event.target.value;\n    calaculateTextSingaturePriceValue(signature);\n  };\n\n  const calaculateHandwrittenSingaturePriceValue = currentSize => {\n    let calculatePriceValue = calculateSignatureSizePrice(customSignatureUnits, currentSize);\n\n    if (isEligibleToDiscount) {\n      calculatePriceValue *= pricePerUnit;\n    } else {\n      calculatePriceValue *= xPricePerUnit;\n    }\n\n    setTotalPrice(calculatePriceValue.toFixed(3));\n  };\n\n  const onChangeHandwrittenSignatureSize = e => {\n    const currentSize = e.target.value;\n    calaculateHandwrittenSingaturePriceValue(currentSize);\n  };\n\n  const LoaderComponent = jsx(React.Fragment, null, jsx(Flex, null, jsx(Text, {\n    as: \"h3\"\n  }, \"Please wait while our minions get some info...\"), jsx(Loader, {\n    sx: styles.loader,\n    type: \"TailSpin\",\n    color: \"#FFC059\",\n    height: 25,\n    width: 25\n  })));\n  useEffect(() => {\n    if (toggleHandSignature) {\n      calaculateHandwrittenSingaturePriceValue(\"small\"); //default size is 'small'\n\n      return;\n    }\n\n    calaculateTextSingaturePriceValue(signature);\n  }, [toggleHandSignature]);\n  useEffect(() => {\n    if (showConfetti) setShowConfetti(false);\n\n    if (!address) {\n      setExistingSignature(null);\n      return;\n    }\n\n    getUserInformation();\n  }, [address]);\n  useEffect(() => {\n    getRandomName();\n    getdefaultValuesFromContract();\n  }, []);\n  return jsx(React.Fragment, null, jsx(Box, {\n    as: \"section\",\n    id: \"home\",\n    sx: (styles.section, styles.random)\n  }, txn && jsx(Modal, {\n    open: openModal,\n    txn: txn,\n    onClose: onCloseModal\n  }), jsx(Container, null, showConfetti && jsx(ConfettiComponent, null), jsx(Box, {\n    sx: styles.contentWrapper\n  }, jsx(Box, {\n    sx: styles.bannerContent\n  }, jsx(Heading, {\n    as: \"h1\"\n  }, \"Get Your Own Personalized NFT Signature\"), jsx(Text, {\n    as: \"p\"\n  }, \"Your NFT Signature is an identity you can use in the Web3 world, any way you want!\"), errorMessage && jsx(Text, {\n    color: \"red\"\n  }, errorMessage), jsx(Flex, {\n    as: \"form\",\n    sx: styles.signatureForm\n  }, isLoading ? LoaderComponent : renderInput()), !existingSignature && jsx(Flex, {\n    as: \"form\",\n    sx: styles.signatureForm\n  }, jsx(Text, {\n    as: \"p\"\n  }, jsx(\"strong\", null, isEligibleToDiscount ? \"Elegible for a discount\" : \"Not elegible for a discount \"), \"\\xA0\"), jsx(Text, {\n    as: \"p\"\n  }, \"MATIC to pay : \", totalPrice))), jsx(Box, null, jsx(Flex, {\n    as: \"figure\",\n    sx: styles.bannerImage\n  }, existingSignature && existingSignature.ipfs_url ? jsx(Image, {\n    src: existingSignature.ipfs_url\n  }) : renderCanvasInput()), toggleHandSignature && !existingSignature && jsx(Flex, {\n    as: \"form\",\n    sx: styles.sizeRadio\n  }, jsx(RadioSelect, {\n    onSizeChange: onChangeHandwrittenSignatureSize\n  }))), renderButton()))));\n};\n\nexport default HomePage;\nconst styles = {\n  section: {\n    backgroundColor: \"#FFFCF7\",\n    pt: [14, null, null, null, null, 0],\n    pb: [6, null, null, 7, 11, 0]\n  },\n  contentWrapper: {\n    gap: [\"50px 50px\"],\n    mt: \"5%\",\n    display: [\"block\", null, null, null, \"grid\"],\n    gridTemplateColumns: [null, null, null, null, \"1fr 1fr\", \"0.95fr 1.05fr\"],\n    alignItems: \"center\",\n    minHeight: [\"auto\", null, null, null, \"38vh\", \"80vh\"],\n    pt: [null, null, null, 8, 0, 9, null],\n    \"@media only screen and (min-width:1900px)\": {\n      pt: 10\n    },\n    a: {\n      textDecoration: \"none\",\n      button: {\n        width: \"100%\"\n      }\n    }\n  },\n  bannerContent: {\n    margin: [null, null, null, \"0 auto\", 0],\n    maxWidth: [null, null, null, 600, \"none\"],\n    textAlign: [null, null, null, \"center\", \"left\"],\n    h1: {\n      fontWeight: 700,\n      fontSize: [8, null, null, 10, 45, null, 12, 14],\n      lineHeight: [1.26, null, null, 1.5, 1.2, 1.26],\n      letterSpacing: [0, null, null, null, \"-1.5px\"],\n      color: \"textSecondary\",\n      \"@media screen and (min-width: 1441px) and (max-width:1600px)\": {\n        fontSize: 12,\n        lineHeight: 1.5\n      }\n    },\n    p: {\n      fontSize: [1, null, null, 2, 3],\n      lineHeight: [1.5, null, null, 2, null, 2.33],\n      color: \"textSecondary\",\n      maxWidth: [470],\n      m: [null, null, null, \"30px auto\", 0],\n      mt: [3, null, null, null, 5]\n    }\n  },\n  signatureForm: {\n    maxWidth: [null, null, null, 470, \"none\"],\n    m: [null, null, null, \"30px auto\", \"30px 0 0\"],\n    mt: [6],\n    input: {\n      backgroundColor: \"#FFFFFF\",\n      border: \"0 none\",\n      fontFamily: \"body\",\n      fontSize: [1, null, null, null, 2],\n      px: [5],\n      boxShadow: \"0px 16px 40px rgba(72, 59, 26, 0.08)\",\n      minHeight: [40, 50, null, null, null, 60],\n\n      /* Chrome, Firefox, Opera, Safari 10.1+ */\n      \"::placeholder\": {\n        color: rgba(\"#02073E\", 0.4),\n        opacity: 1\n        /* Firefox */\n\n      }\n    },\n    button: {\n      fontSize: [0, 1, null, null, 2],\n      minHeight: [40, 50, null, null, null, 60]\n    }\n  },\n  loader: {\n    marginLeft: \"1em\"\n  },\n  sizeRadio: {\n    mt: \"2%\" // mt: [10],\n\n  },\n  sponsoredBy: {\n    alignItems: \"center\",\n    maxWidth: [null, null, null, 470, \"none\"],\n    m: [null, null, null, \"30px auto\", \"30px 0 0\"],\n    mt: [6],\n    span: {\n      fontSize: [\"13px\", null, null, null, 2],\n      lineHeight: 2.62,\n      color: rgba(\"#566272\", 0.6)\n    }\n  },\n  sponsor: {\n    alignItems: \"center\",\n    figure: {\n      ml: [2, null, null, null, 4, 5],\n      img: {\n        maxWidth: [\"60px\", null, null, null, \"80px\", \"100%\"]\n      }\n    }\n  },\n  signatureText: {\n    fontFamily: \"Gochi Hand, cursive\",\n    fontSize: [38, null, null, null, 38],\n    color: \"primary\"\n  },\n  bannerImage: {\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    mt: [0, null, null, null, 0],\n    img: {\n      maxWidth: [null, null, null, \"80%\", \"100%\"],\n      m: [0, null, null, \"0 auto\", 0]\n    },\n    backgroundColor: \"black\",\n    borderRadius: \"1.25rem\",\n    height: \"400px\"\n  }\n};","map":null,"metadata":{},"sourceType":"module"}