{"ast":null,"code":"import _regeneratorRuntime from \"/home/harshitsinghai/Documents/Projects/web3/signature-dao/frontend/node_modules/next/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/harshitsinghai/Documents/Projects/web3/signature-dao/frontend/node_modules/next/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport React from \"react\";\nvar __jsx = React.createElement;\nimport axios from \"axios\";\nimport { Web3Storage } from \"web3.storage/dist/bundle.esm.min.cjs\";\nimport { renderToStaticMarkup } from \"react-dom/server\";\n\nfunction getAccessToken() {\n  // If you're just testing, you can paste in a token\n  // and uncomment the following line:\n  // return 'paste-your-token-here'\n  // In a real app, it's better to read an access token from an\n  // environement variable or other configuration that's kept outside of\n  // your code base. For this to work, you need to set the\n  // WEB3STORAGE_TOKEN environment variable before you run your code.\n  return process.env.NEXT_PUBLIC_WEB3STORAGE_TOKEN;\n}\n\nfunction makeStorageClient() {\n  return new Web3Storage({\n    token: getAccessToken()\n  });\n}\n\nexport var IPFS_RETRIEVE_URL = \"https://w3s.link/ipfs/\";\nexport var exportSignatureAsSVG = function exportSignatureAsSVG(signature) {\n  var imgSVG = __jsx(\"svg\", {\n    id: \"mysvg\",\n    xmlns: \"http://www.w3.org/2000/svg\",\n    preserveAspectRatio: \"xMinYMin meet\",\n    viewBox: \"0 0 350 350\",\n    fill: \"#FFC059\"\n  }, __jsx(\"rect\", {\n    width: \"100%\",\n    height: \"70%\",\n    fill: \"black\"\n  }), __jsx(\"text\", {\n    x: \"50%\",\n    y: \"25%\",\n    textAnchor: \"middle\",\n    style: {\n      fontFamily: \"Gochi Hand, cursive\",\n      fontSize: \"28px\"\n    }\n  }, __jsx(\"tspan\", {\n    x: \"50%\",\n    dy: \"1.2em\"\n  }, signature)));\n\n  return renderToStaticMarkup(imgSVG);\n};\nexport var exportSignatureAsPNGFile = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(base64EncodedImage) {\n    var fetchSignature, blob, file;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return fetch(base64EncodedImage);\n\n          case 2:\n            fetchSignature = _context.sent;\n            _context.next = 5;\n            return fetchSignature.blob();\n\n          case 5:\n            blob = _context.sent;\n            file = new File([blob], \"signature.png\", {\n              type: \"image/png\"\n            });\n            return _context.abrupt(\"return\", file);\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function exportSignatureAsPNGFile(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport var convertToBuffer = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(svgElement) {\n    var svgBuffer;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            svgBuffer = Buffer.from(svgElement);\n            return _context2.abrupt(\"return\", svgBuffer);\n\n          case 2:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function convertToBuffer(_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}(); // export const addDataToNFTStorage = async (metadata) => {\n//   const metadata = await nftStorageClient.store({\n//     name: \"Pinpie\",\n//     description: \"Pin is not delicious beef!\",\n//     image: new NFTStorageFile(\n//       [\n//         /* data */\n//       ],\n//       \"pinpie.jpg\",\n//       { type: \"image/jpg\" }\n//     ),\n//   });\n//   console.log(metadata.url);\n// };\n\nexport var addDataToIPFS = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(metadata) {\n    var metadataTypeImage,\n        client,\n        newMetadata,\n        blob,\n        hash,\n        _args3 = arguments;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            metadataTypeImage = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : false;\n            client = makeStorageClient();\n            newMetadata = null;\n\n            if (metadataTypeImage) {\n              newMetadata = [metadata];\n            } else {\n              blob = new Blob([JSON.stringify(metadata)], {\n                type: \"application/json\"\n              });\n              newMetadata = [new File([blob], \"hello.json\")];\n            }\n\n            _context3.next = 6;\n            return client.put(newMetadata);\n\n          case 6:\n            hash = _context3.sent;\n            return _context3.abrupt(\"return\", hash);\n\n          case 8:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function addDataToIPFS(_x3) {\n    return _ref3.apply(this, arguments);\n  };\n}();\nexport var retrieveDataFromIPFS = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(ipfsHash) {\n    var result;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return axios.get(\"https://\".concat(ipfsHash, \".ipfs.w3s.link/hello.json\"));\n\n          case 2:\n            result = _context4.sent;\n            return _context4.abrupt(\"return\", result);\n\n          case 4:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function retrieveDataFromIPFS(_x4) {\n    return _ref4.apply(this, arguments);\n  };\n}();\nexport var createNFTMeta = function createNFTMeta(imgHash, signature) {\n  // More Information - https://docs.opensea.io/docs/metadata-standards\n  return {\n    image: \"https://ipfs.io/ipfs/\".concat(imgHash),\n    web3Storage: \"https://\".concat(imgHash, \".ipfs.w3s.link/signature.png\"),\n    name: signature,\n    description: \"An NFT from the highly acclaimed OneMillionSignature DAO\",\n    attributes: [{\n      trait_type: \"Signature\",\n      value: signature\n    }, {\n      display_type: \"date\",\n      trait_type: \"minted on\",\n      value: Date.now()\n    }]\n  };\n};","map":null,"metadata":{},"sourceType":"module"}